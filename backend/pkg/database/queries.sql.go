// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const BulkUpdateCredentialStatus = `-- name: BulkUpdateCredentialStatus :exec
UPDATE credentials
SET revoked = $1, revoked_at = CASE WHEN $1 THEN NOW() ELSE NULL END
WHERE id = ANY($2::uuid[])
`

type BulkUpdateCredentialStatusParams struct {
	Revoked bool          `db:"revoked" json:"revoked"`
	Column2 []pgtype.UUID `db:"column_2" json:"column_2"`
}

func (q *Queries) BulkUpdateCredentialStatus(ctx context.Context, arg BulkUpdateCredentialStatusParams) error {
	_, err := q.db.Exec(ctx, BulkUpdateCredentialStatus, arg.Revoked, arg.Column2)
	return err
}

const CreateAuditLog = `-- name: CreateAuditLog :exec
INSERT INTO audit_logs (actor, action, obj, meta)
VALUES ($1, $2, $3, $4)
`

type CreateAuditLogParams struct {
	Actor  string `db:"actor" json:"actor"`
	Action string `db:"action" json:"action"`
	Obj    string `db:"obj" json:"obj"`
	Meta   []byte `db:"meta" json:"meta"`
}

func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) error {
	_, err := q.db.Exec(ctx, CreateAuditLog,
		arg.Actor,
		arg.Action,
		arg.Obj,
		arg.Meta,
	)
	return err
}

const CreateCredential = `-- name: CreateCredential :one
INSERT INTO credentials (subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, anchor_chain, anchor_tx)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at
`

type CreateCredentialParams struct {
	SubjectDid  string      `db:"subject_did" json:"subject_did"`
	IssuerDid   string      `db:"issuer_did" json:"issuer_did"`
	VcHash      []byte      `db:"vc_hash" json:"vc_hash"`
	VcJws       []byte      `db:"vc_jws" json:"vc_jws"`
	Type        []string    `db:"type" json:"type"`
	IssuedAt    time.Time   `db:"issued_at" json:"issued_at"`
	ExpiresAt   *time.Time  `db:"expires_at" json:"expires_at"`
	AnchorChain pgtype.Text `db:"anchor_chain" json:"anchor_chain"`
	AnchorTx    pgtype.Text `db:"anchor_tx" json:"anchor_tx"`
}

func (q *Queries) CreateCredential(ctx context.Context, arg CreateCredentialParams) (Credential, error) {
	row := q.db.QueryRow(ctx, CreateCredential,
		arg.SubjectDid,
		arg.IssuerDid,
		arg.VcHash,
		arg.VcJws,
		arg.Type,
		arg.IssuedAt,
		arg.ExpiresAt,
		arg.AnchorChain,
		arg.AnchorTx,
	)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.SubjectDid,
		&i.IssuerDid,
		&i.VcHash,
		&i.VcJws,
		&i.Type,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.AnchorChain,
		&i.AnchorTx,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateKYCJob = `-- name: CreateKYCJob :one
INSERT INTO kyc_jobs (user_id, status, score, liveness, doc_valid, result_json)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, status, score, liveness, doc_valid, result_json, created_at, updated_at
`

type CreateKYCJobParams struct {
	UserID     pgtype.UUID    `db:"user_id" json:"user_id"`
	Status     KycStatus      `db:"status" json:"status"`
	Score      pgtype.Numeric `db:"score" json:"score"`
	Liveness   pgtype.Bool    `db:"liveness" json:"liveness"`
	DocValid   pgtype.Bool    `db:"doc_valid" json:"doc_valid"`
	ResultJson []byte         `db:"result_json" json:"result_json"`
}

func (q *Queries) CreateKYCJob(ctx context.Context, arg CreateKYCJobParams) (KycJob, error) {
	row := q.db.QueryRow(ctx, CreateKYCJob,
		arg.UserID,
		arg.Status,
		arg.Score,
		arg.Liveness,
		arg.DocValid,
		arg.ResultJson,
	)
	var i KycJob
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Score,
		&i.Liveness,
		&i.DocValid,
		&i.ResultJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateRevocation = `-- name: CreateRevocation :one
INSERT INTO revocations (vc_hash, reason)
VALUES ($1, $2)
RETURNING vc_hash, reason, revoked_at
`

type CreateRevocationParams struct {
	VcHash []byte `db:"vc_hash" json:"vc_hash"`
	Reason string `db:"reason" json:"reason"`
}

func (q *Queries) CreateRevocation(ctx context.Context, arg CreateRevocationParams) (Revocation, error) {
	row := q.db.QueryRow(ctx, CreateRevocation, arg.VcHash, arg.Reason)
	var i Revocation
	err := row.Scan(&i.VcHash, &i.Reason, &i.RevokedAt)
	return i, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (did, risk_score)
VALUES ($1, $2)
RETURNING id, did, created_at, last_seen_at, risk_score
`

type CreateUserParams struct {
	Did       string         `db:"did" json:"did"`
	RiskScore pgtype.Numeric `db:"risk_score" json:"risk_score"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, CreateUser, arg.Did, arg.RiskScore)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Did,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.RiskScore,
	)
	return i, err
}

const DeleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteUser, id)
	return err
}

const GetAuditLogs = `-- name: GetAuditLogs :many
SELECT id, actor, action, obj, meta, ts FROM audit_logs
WHERE actor = $1
ORDER BY ts DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsParams struct {
	Actor  string `db:"actor" json:"actor"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAuditLogs(ctx context.Context, arg GetAuditLogsParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogs, arg.Actor, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.Obj,
			&i.Meta,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsByAction = `-- name: GetAuditLogsByAction :many
SELECT id, actor, action, obj, meta, ts FROM audit_logs
WHERE action = $1
ORDER BY ts DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByActionParams struct {
	Action string `db:"action" json:"action"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAuditLogsByAction(ctx context.Context, arg GetAuditLogsByActionParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsByAction, arg.Action, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.Obj,
			&i.Meta,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsByObject = `-- name: GetAuditLogsByObject :many
SELECT id, actor, action, obj, meta, ts FROM audit_logs
WHERE obj = $1
ORDER BY ts DESC
LIMIT $2 OFFSET $3
`

type GetAuditLogsByObjectParams struct {
	Obj    string `db:"obj" json:"obj"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetAuditLogsByObject(ctx context.Context, arg GetAuditLogsByObjectParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsByObject, arg.Obj, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.Obj,
			&i.Meta,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditLogsByTimeRange = `-- name: GetAuditLogsByTimeRange :many
SELECT id, actor, action, obj, meta, ts FROM audit_logs
WHERE ts >= $1 AND ts <= $2
ORDER BY ts DESC
LIMIT $3 OFFSET $4
`

type GetAuditLogsByTimeRangeParams struct {
	Ts     time.Time `db:"ts" json:"ts"`
	Ts_2   time.Time `db:"ts_2" json:"ts_2"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetAuditLogsByTimeRange(ctx context.Context, arg GetAuditLogsByTimeRangeParams) ([]AuditLog, error) {
	rows, err := q.db.Query(ctx, GetAuditLogsByTimeRange,
		arg.Ts,
		arg.Ts_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditLog{}
	for rows.Next() {
		var i AuditLog
		if err := rows.Scan(
			&i.ID,
			&i.Actor,
			&i.Action,
			&i.Obj,
			&i.Meta,
			&i.Ts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCredential = `-- name: GetCredential :one
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE id = $1
`

func (q *Queries) GetCredential(ctx context.Context, id pgtype.UUID) (Credential, error) {
	row := q.db.QueryRow(ctx, GetCredential, id)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.SubjectDid,
		&i.IssuerDid,
		&i.VcHash,
		&i.VcJws,
		&i.Type,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.AnchorChain,
		&i.AnchorTx,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCredentialByHash = `-- name: GetCredentialByHash :one
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE vc_hash = $1
`

func (q *Queries) GetCredentialByHash(ctx context.Context, vcHash []byte) (Credential, error) {
	row := q.db.QueryRow(ctx, GetCredentialByHash, vcHash)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.SubjectDid,
		&i.IssuerDid,
		&i.VcHash,
		&i.VcJws,
		&i.Type,
		&i.IssuedAt,
		&i.ExpiresAt,
		&i.Revoked,
		&i.RevokedAt,
		&i.AnchorChain,
		&i.AnchorTx,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetCredentialStats = `-- name: GetCredentialStats :one
SELECT 
    COUNT(*) as total_credentials,
    COUNT(*) FILTER (WHERE revoked = FALSE) as active_credentials,
    COUNT(*) FILTER (WHERE revoked = TRUE) as revoked_credentials,
    COUNT(*) FILTER (WHERE expires_at IS NOT NULL AND expires_at < NOW()) as expired_credentials,
    COUNT(*) FILTER (WHERE anchor_tx IS NOT NULL) as anchored_credentials
FROM credentials
`

type GetCredentialStatsRow struct {
	TotalCredentials    int64 `db:"total_credentials" json:"total_credentials"`
	ActiveCredentials   int64 `db:"active_credentials" json:"active_credentials"`
	RevokedCredentials  int64 `db:"revoked_credentials" json:"revoked_credentials"`
	ExpiredCredentials  int64 `db:"expired_credentials" json:"expired_credentials"`
	AnchoredCredentials int64 `db:"anchored_credentials" json:"anchored_credentials"`
}

func (q *Queries) GetCredentialStats(ctx context.Context) (GetCredentialStatsRow, error) {
	row := q.db.QueryRow(ctx, GetCredentialStats)
	var i GetCredentialStatsRow
	err := row.Scan(
		&i.TotalCredentials,
		&i.ActiveCredentials,
		&i.RevokedCredentials,
		&i.ExpiredCredentials,
		&i.AnchoredCredentials,
	)
	return i, err
}

const GetCredentialsByDateRange = `-- name: GetCredentialsByDateRange :many
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE issued_at >= $1 AND issued_at <= $2
ORDER BY issued_at DESC
LIMIT $3 OFFSET $4
`

type GetCredentialsByDateRangeParams struct {
	IssuedAt   time.Time `db:"issued_at" json:"issued_at"`
	IssuedAt_2 time.Time `db:"issued_at_2" json:"issued_at_2"`
	Limit      int32     `db:"limit" json:"limit"`
	Offset     int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetCredentialsByDateRange(ctx context.Context, arg GetCredentialsByDateRangeParams) ([]Credential, error) {
	rows, err := q.db.Query(ctx, GetCredentialsByDateRange,
		arg.IssuedAt,
		arg.IssuedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCredentialsByIssuer = `-- name: GetCredentialsByIssuer :many
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE issuer_did = $1
ORDER BY issued_at DESC
LIMIT $2 OFFSET $3
`

type GetCredentialsByIssuerParams struct {
	IssuerDid string `db:"issuer_did" json:"issuer_did"`
	Limit     int32  `db:"limit" json:"limit"`
	Offset    int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetCredentialsByIssuer(ctx context.Context, arg GetCredentialsByIssuerParams) ([]Credential, error) {
	rows, err := q.db.Query(ctx, GetCredentialsByIssuer, arg.IssuerDid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCredentialsBySubject = `-- name: GetCredentialsBySubject :many
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE subject_did = $1 AND revoked = FALSE
ORDER BY issued_at DESC
`

func (q *Queries) GetCredentialsBySubject(ctx context.Context, subjectDid string) ([]Credential, error) {
	rows, err := q.db.Query(ctx, GetCredentialsBySubject, subjectDid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCredentialsByType = `-- name: GetCredentialsByType :many
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE $1 = ANY(type) AND revoked = FALSE
ORDER BY issued_at DESC
LIMIT $2 OFFSET $3
`

type GetCredentialsByTypeParams struct {
	Type   []string `db:"type" json:"type"`
	Limit  int32    `db:"limit" json:"limit"`
	Offset int32    `db:"offset" json:"offset"`
}

func (q *Queries) GetCredentialsByType(ctx context.Context, arg GetCredentialsByTypeParams) ([]Credential, error) {
	rows, err := q.db.Query(ctx, GetCredentialsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetCredentialsForRevocation = `-- name: GetCredentialsForRevocation :many
SELECT c.id, c.subject_did, c.issuer_did, c.vc_hash, c.vc_jws, c.type, c.issued_at, c.expires_at, c.revoked, c.revoked_at, c.anchor_chain, c.anchor_tx, c.created_at, c.updated_at FROM credentials c
INNER JOIN revocations r ON c.vc_hash = r.vc_hash
WHERE r.revoked_at >= $1
`

func (q *Queries) GetCredentialsForRevocation(ctx context.Context, revokedAt *time.Time) ([]Credential, error) {
	rows, err := q.db.Query(ctx, GetCredentialsForRevocation, revokedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetExpiredCredentials = `-- name: GetExpiredCredentials :many
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE expires_at IS NOT NULL AND expires_at < NOW() AND revoked = FALSE
`

func (q *Queries) GetExpiredCredentials(ctx context.Context) ([]Credential, error) {
	rows, err := q.db.Query(ctx, GetExpiredCredentials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKYCJob = `-- name: GetKYCJob :one
SELECT id, user_id, status, score, liveness, doc_valid, result_json, created_at, updated_at FROM kyc_jobs
WHERE id = $1
`

func (q *Queries) GetKYCJob(ctx context.Context, id pgtype.UUID) (KycJob, error) {
	row := q.db.QueryRow(ctx, GetKYCJob, id)
	var i KycJob
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Score,
		&i.Liveness,
		&i.DocValid,
		&i.ResultJson,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetKYCJobsByUser = `-- name: GetKYCJobsByUser :many
SELECT id, user_id, status, score, liveness, doc_valid, result_json, created_at, updated_at FROM kyc_jobs
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetKYCJobsByUser(ctx context.Context, userID pgtype.UUID) ([]KycJob, error) {
	rows, err := q.db.Query(ctx, GetKYCJobsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KycJob{}
	for rows.Next() {
		var i KycJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.Score,
			&i.Liveness,
			&i.DocValid,
			&i.ResultJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetKYCStats = `-- name: GetKYCStats :one
SELECT 
    COUNT(*) as total_jobs,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_jobs,
    COUNT(*) FILTER (WHERE status = 'processing') as processing_jobs,
    COUNT(*) FILTER (WHERE status = 'passed') as passed_jobs,
    COUNT(*) FILTER (WHERE status = 'failed') as failed_jobs,
    AVG(score) FILTER (WHERE score IS NOT NULL) as avg_score
FROM kyc_jobs
`

type GetKYCStatsRow struct {
	TotalJobs      int64   `db:"total_jobs" json:"total_jobs"`
	PendingJobs    int64   `db:"pending_jobs" json:"pending_jobs"`
	ProcessingJobs int64   `db:"processing_jobs" json:"processing_jobs"`
	PassedJobs     int64   `db:"passed_jobs" json:"passed_jobs"`
	FailedJobs     int64   `db:"failed_jobs" json:"failed_jobs"`
	AvgScore       float64 `db:"avg_score" json:"avg_score"`
}

func (q *Queries) GetKYCStats(ctx context.Context) (GetKYCStatsRow, error) {
	row := q.db.QueryRow(ctx, GetKYCStats)
	var i GetKYCStatsRow
	err := row.Scan(
		&i.TotalJobs,
		&i.PendingJobs,
		&i.ProcessingJobs,
		&i.PassedJobs,
		&i.FailedJobs,
		&i.AvgScore,
	)
	return i, err
}

const GetRevocation = `-- name: GetRevocation :one
SELECT vc_hash, reason, revoked_at FROM revocations
WHERE vc_hash = $1
`

func (q *Queries) GetRevocation(ctx context.Context, vcHash []byte) (Revocation, error) {
	row := q.db.QueryRow(ctx, GetRevocation, vcHash)
	var i Revocation
	err := row.Scan(&i.VcHash, &i.Reason, &i.RevokedAt)
	return i, err
}

const GetUser = `-- name: GetUser :one
SELECT id, did, created_at, last_seen_at, risk_score FROM users
WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, GetUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Did,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.RiskScore,
	)
	return i, err
}

const GetUserByDID = `-- name: GetUserByDID :one
SELECT id, did, created_at, last_seen_at, risk_score FROM users
WHERE did = $1
`

func (q *Queries) GetUserByDID(ctx context.Context, did string) (User, error) {
	row := q.db.QueryRow(ctx, GetUserByDID, did)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Did,
		&i.CreatedAt,
		&i.LastSeenAt,
		&i.RiskScore,
	)
	return i, err
}

const GetUserStats = `-- name: GetUserStats :one
SELECT 
    COUNT(*) as total_users,
    COUNT(*) FILTER (WHERE last_seen_at > NOW() - INTERVAL '24 hours') as active_users_24h,
    COUNT(*) FILTER (WHERE last_seen_at > NOW() - INTERVAL '7 days') as active_users_7d,
    AVG(risk_score) as avg_risk_score
FROM users
`

type GetUserStatsRow struct {
	TotalUsers     int64   `db:"total_users" json:"total_users"`
	ActiveUsers24h int64   `db:"active_users_24h" json:"active_users_24h"`
	ActiveUsers7d  int64   `db:"active_users_7d" json:"active_users_7d"`
	AvgRiskScore   float64 `db:"avg_risk_score" json:"avg_risk_score"`
}

func (q *Queries) GetUserStats(ctx context.Context) (GetUserStatsRow, error) {
	row := q.db.QueryRow(ctx, GetUserStats)
	var i GetUserStatsRow
	err := row.Scan(
		&i.TotalUsers,
		&i.ActiveUsers24h,
		&i.ActiveUsers7d,
		&i.AvgRiskScore,
	)
	return i, err
}

const ListKYCJobs = `-- name: ListKYCJobs :many
SELECT id, user_id, status, score, liveness, doc_valid, result_json, created_at, updated_at FROM kyc_jobs
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListKYCJobsParams struct {
	Status KycStatus `db:"status" json:"status"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListKYCJobs(ctx context.Context, arg ListKYCJobsParams) ([]KycJob, error) {
	rows, err := q.db.Query(ctx, ListKYCJobs, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []KycJob{}
	for rows.Next() {
		var i KycJob
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.Score,
			&i.Liveness,
			&i.DocValid,
			&i.ResultJson,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRevocations = `-- name: ListRevocations :many
SELECT vc_hash, reason, revoked_at FROM revocations
ORDER BY revoked_at DESC
LIMIT $1 OFFSET $2
`

type ListRevocationsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListRevocations(ctx context.Context, arg ListRevocationsParams) ([]Revocation, error) {
	rows, err := q.db.Query(ctx, ListRevocations, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Revocation{}
	for rows.Next() {
		var i Revocation
		if err := rows.Scan(&i.VcHash, &i.Reason, &i.RevokedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUsers = `-- name: ListUsers :many
SELECT id, did, created_at, last_seen_at, risk_score FROM users
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, ListUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Did,
			&i.CreatedAt,
			&i.LastSeenAt,
			&i.RiskScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RevokeCredential = `-- name: RevokeCredential :exec
UPDATE credentials
SET revoked = TRUE, revoked_at = NOW()
WHERE vc_hash = $1
`

func (q *Queries) RevokeCredential(ctx context.Context, vcHash []byte) error {
	_, err := q.db.Exec(ctx, RevokeCredential, vcHash)
	return err
}

const SearchCredentials = `-- name: SearchCredentials :many
SELECT id, subject_did, issuer_did, vc_hash, vc_jws, type, issued_at, expires_at, revoked, revoked_at, anchor_chain, anchor_tx, created_at, updated_at FROM credentials
WHERE 
    (subject_did ILIKE '%' || $1 || '%' OR issuer_did ILIKE '%' || $1 || '%')
    AND ($2::boolean IS NULL OR revoked = $2)
    AND ($3::text IS NULL OR $3 = ANY(type))
ORDER BY issued_at DESC
LIMIT $4 OFFSET $5
`

type SearchCredentialsParams struct {
	Column1 pgtype.Text `db:"column_1" json:"column_1"`
	Column2 bool        `db:"column_2" json:"column_2"`
	Column3 string      `db:"column_3" json:"column_3"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

func (q *Queries) SearchCredentials(ctx context.Context, arg SearchCredentialsParams) ([]Credential, error) {
	rows, err := q.db.Query(ctx, SearchCredentials,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.SubjectDid,
			&i.IssuerDid,
			&i.VcHash,
			&i.VcJws,
			&i.Type,
			&i.IssuedAt,
			&i.ExpiresAt,
			&i.Revoked,
			&i.RevokedAt,
			&i.AnchorChain,
			&i.AnchorTx,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateCredentialAnchor = `-- name: UpdateCredentialAnchor :exec
UPDATE credentials
SET anchor_chain = $2, anchor_tx = $3
WHERE id = $1
`

type UpdateCredentialAnchorParams struct {
	ID          pgtype.UUID `db:"id" json:"id"`
	AnchorChain pgtype.Text `db:"anchor_chain" json:"anchor_chain"`
	AnchorTx    pgtype.Text `db:"anchor_tx" json:"anchor_tx"`
}

func (q *Queries) UpdateCredentialAnchor(ctx context.Context, arg UpdateCredentialAnchorParams) error {
	_, err := q.db.Exec(ctx, UpdateCredentialAnchor, arg.ID, arg.AnchorChain, arg.AnchorTx)
	return err
}

const UpdateKYCJobStatus = `-- name: UpdateKYCJobStatus :exec
UPDATE kyc_jobs
SET status = $2, score = $3, liveness = $4, doc_valid = $5, result_json = $6
WHERE id = $1
`

type UpdateKYCJobStatusParams struct {
	ID         pgtype.UUID    `db:"id" json:"id"`
	Status     KycStatus      `db:"status" json:"status"`
	Score      pgtype.Numeric `db:"score" json:"score"`
	Liveness   pgtype.Bool    `db:"liveness" json:"liveness"`
	DocValid   pgtype.Bool    `db:"doc_valid" json:"doc_valid"`
	ResultJson []byte         `db:"result_json" json:"result_json"`
}

func (q *Queries) UpdateKYCJobStatus(ctx context.Context, arg UpdateKYCJobStatusParams) error {
	_, err := q.db.Exec(ctx, UpdateKYCJobStatus,
		arg.ID,
		arg.Status,
		arg.Score,
		arg.Liveness,
		arg.DocValid,
		arg.ResultJson,
	)
	return err
}

const UpdateUserLastSeen = `-- name: UpdateUserLastSeen :exec
UPDATE users
SET last_seen_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateUserLastSeen(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, UpdateUserLastSeen, id)
	return err
}

const UpdateUserRiskScore = `-- name: UpdateUserRiskScore :exec
UPDATE users
SET risk_score = $2
WHERE id = $1
`

type UpdateUserRiskScoreParams struct {
	ID        pgtype.UUID    `db:"id" json:"id"`
	RiskScore pgtype.Numeric `db:"risk_score" json:"risk_score"`
}

func (q *Queries) UpdateUserRiskScore(ctx context.Context, arg UpdateUserRiskScoreParams) error {
	_, err := q.db.Exec(ctx, UpdateUserRiskScore, arg.ID, arg.RiskScore)
	return err
}
