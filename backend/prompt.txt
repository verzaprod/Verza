

# Verza Development Prompt — Golang Backend + Blockchain for Verifiable Credentials

## 0) Goal

Build a **Go (Golang)** backend that:

* Verifies user identity (face + ID) via a separate ML service,
* Issues **W3C Verifiable Credentials (VCs)** to user DIDs,
* Supports **DID methods** (`did:key`, `did:peer`, `did:web` for issuer; `did:key`/`did:peer` for users),
* **Anchors VC proofs** (hashes + revocation events) on an **EVM chain** (Polygon/Base),
* Exposes **REST + gRPC** APIs for issuance, presentation, verification, and revocation,
* Implements **zero-knowledge selective disclosure** (where feasible) and **bank-grade security**,
* Provides **encrypted cloud backup + seed phrase recovery** (client-side).

---

## 1) Tech Stack (Hard Requirements)

* **Language:** Go 1.22+
* **API:** `gin-gonic` (REST), `grpc-go` (internal services)
* **VC/DID:** `hyperledger/aries-framework-go` (use the `verifiable` & DID docs packages only)
* **Signing (JWS/JWT/JOSE):** `github.com/square/go-jose/v3`
* **DB:** PostgreSQL 15+ (with pgcrypto) via `sqlc` (preferred) or `pgx`
* **Cache/Queues:** Redis 7 (rate limiting, jobs), NATS or RabbitMQ (optional for async)
* **KMS/HSM:** HashiCorp Vault or AWS KMS (envelope encryption + key rotation)
* **Object Storage:** S3-compatible (minio in dev) for **temporary** encrypted blobs
* **Blockchain:** Solidity smart contracts (EVM), `go-ethereum` + `abigen` for client
* **Secrets/Configs:** 12-factor, Doppler or Vault
* **CI/CD:** GitHub Actions (SAST + DAST), Terraform for infra

---

## 2) High-Level Services (Microservice Layout)

1. **api-gateway** (Go): REST/gRPC ingress, authn/z, rate-limit, request signing.
2. **issuer-svc** (Go): VC creation, signing, registry anchoring, revocation.
3. **verifier-svc** (Go): VP/VC validation, signature check, revocation & chain checks, ZK proof verify.
4. **did-svc** (Go): DID generation/resolution (`did:key`, `did:peer`, `did:web` for issuer), DID Document ops.
5. **ml-verifier** (Python, separate): Face liveness, ID OCR, face match score. (API called by issuer-svc.)
6. **anchor-svc** (Go): EVM interaction (anchor, revoke), event listeners → audit DB.
7. **audit-log-svc** (Go): append-only logs, export to SIEM; optional on-chain hash anchoring.

> Note: **No raw biometrics** persisted. Temporary encrypted blobs auto-delete with short TTL.

---

## 3) Data & Crypto Model

* **VC Format:** W3C **JSON-LD**; support **JWT-VC** (optional).
* **Signature Suites:**

  * Default: **Ed25519Signature2020** (EdDSA).
  * Alt: `EcdsaSecp256k1Signature2019` for EVM ecosystem compatibility.
* **DID Methods:**

  * Users: `did:key` (default), `did:peer` (for pairwise),
  * Issuer: `did:web` (bank-friendly) + `did:key` (crypto-native).
* **Anchoring:** Store **sha256(VC normalized)** or **sha256(VP nonce-binding)** on chain + metadata (issuer DID, timestamp). No PII on chain.
* **Revocation:** On-chain registry + off-chain status list (StatusList2021) for fast checks.

---

## 4) Smart Contracts (Solidity — EVM)

**Contract: `VCRegistry`**

* **Storage**

  * `mapping(bytes32 => CredentialRecord)` where `bytes32` = VC hash
  * `struct CredentialRecord { address issuer; uint64 issuedAt; bool revoked; uint64 revokedAt; string uri; }`
* **Functions**

  * `anchor(bytes32 vcHash, string uri)` → onlyAuthorizedIssuer
  * `revoke(bytes32 vcHash)` → onlyOriginalIssuer
  * `isValid(bytes32 vcHash) view returns (bool valid, bool revoked, uint64 issuedAt, uint64 revokedAt, string uri)`
  * `registerIssuer(address issuer)` / `revokeIssuer(address issuer)` (AccessControl)
* **Events**

  * `Anchored(bytes32 vcHash, address issuer, uint64 issuedAt, string uri)`
  * `Revoked(bytes32 vcHash, address issuer, uint64 revokedAt)`
  * `IssuerAdded(address issuer)` / `IssuerRemoved(address issuer)`
* **Security**

  * OpenZeppelin **AccessControl**; **pausable**; **upgradeable** (UUPS) optional
  * Chain: **Polygon** (low fees) or **Base** (low fees + good tooling)
* **Go Integration**

  * Compile with `abigen`; generate `vcregistry.go`
  * Anchor/revoke via `anchor-svc` with **gas price management** & **nonce queues**

---

## 5) API Spec (REST) — Minimal but Complete

### Auth

* **Partners (banks):** OAuth 2.1 (client credentials) + **mTLS**
* **Mobile app:** DID-Auth (challenge → signed by user’s private key) + short-lived JWT from gateway

### Endpoints

1. `POST /v1/kyc/submit`

   * body: `{ selfieRef, idFrontRef, idBackRef, userDID }` (object storage refs)
   * flow: enqueue ML check → response `{ jobId }`
2. `GET /v1/kyc/result/:jobId`

   * returns `{ score: float, liveness: bool, docValid: bool, ocr: {...} }`
3. `POST /v1/vc/issue` (requires KYC pass)

   * body: `{ subjectDID, claims, expiry? }`
   * server: build VC (JSON-LD), sign via KMS, **anchor on chain**, store **status in DB**
   * returns `{ vc: JSON, anchorTx: { chainId, txHash } }`
4. `POST /v1/vp/verify`

   * body: `{ vp, options: { challenge, domain } }`
   * verify VP signature, nonce binding, check anchors & revocation → `{ valid: bool, details }`
5. `POST /v1/vc/revoke` (issuer-only)

   * body: `{ vcHash, reason? }` → on-chain revoke + update StatusList2021
6. `GET /v1/status/:vcHash`

   * returns `{ anchored: bool, revoked: bool, issuedAt, revokedAt, anchorTx, uri }`
7. `POST /v1/did/resolve`

   * body: `{ did }` → returns DID Document (cache results)
8. `POST /v1/backup/register`

   * registers **client-side encrypted** backup metadata (never plaintext keys)
9. `POST /v1/auth/did-challenge` → `{ did }` → returns `{ challenge, domain }`
10. `POST /v1/auth/did-response` → `{ did, signature }` → returns JWT (15 min)

> All uploads are **client-side encrypted**; backend sees only encrypted blobs + ephemeral processing.

---

## 6) Persistence Schema (Postgres via sqlc)

* `users(id uuid pk, did text unique, created_at, last_seen_at, risk_score numeric)`
* `kyc_jobs(id uuid pk, user_id, status enum, score numeric, liveness bool, doc_valid bool, result_json jsonb, created_at)`
* `credentials(id uuid pk, subject_did text, issuer_did text, vc_hash bytea unique, vc_jws bytea, type text[], issued_at, expires_at, revoked bool, revoked_at, anchor_chain text, anchor_tx text)`
* `revocations(vc_hash bytea pk, reason text, revoked_at)`
* `audit_logs(id bigserial pk, actor text, action text, obj text, meta jsonb, ts timestamptz)`
  (Append-only; no deletes)

---

## 7) Key Management & Signing

* **Issuer keys** live in **Vault/KMS** (ed25519 + secp256k1).
* All VC/VP signing via **remote KMS**; app code never sees raw private keys.
* **Key rotation:** every 90 days minimum; maintain versioned verification methods in issuer DID Document.
* **DID Documents** published for issuer (`did:web`) with updated verification methods and **revocation list URL**.

---

## 8) Security Controls (Bank-Grade)

* **Transport:** TLS 1.3 everywhere; **mTLS** for partner/between services with SPIFFE IDs
* **AuthZ:** RBAC + ABAC; least privilege; policy as code (OPA)
* **Input Hardening:** strict JSON schema validation; size limits; MIME allow-lists
* **Rate Limiting:** IP + DID + client-id; sliding window + token bucket (Redis)
* **Secrets:** never in env/plaintext logs; fetch just-in-time from Vault
* **PII:** minimize. No raw biometrics at rest. Temporary encrypted S3 objects auto-purge (≤15 min)
* **Crypto:** AES-256-GCM (envelope with KMS CMK), Argon2id for any user-chosen secrets (e.g., backup passphrase derivation)
* **ZK/Selective Disclosure:** support BBS+ / SD-JWT-VC (where feasible); otherwise restrict to field-level disclosures
* **Logging:** structured, redacted, high-cardinality controls; log **hashes**, not payloads
* **Threats Coverage:** replay protection (nonce), anti-automation (risk scoring), signature timestamping, chain reorg handling
* **Compliance:** GDPR (erasure of server-side temp artifacts), SOC2 (controls), AML/KYC audit logs

---

## 9) VC Lifecycle (State Machine)

1. **KYC\_PENDING** → **KYC\_PASSED** (via `ml-verifier`)
2. **VC\_CREATED** (unsigned JSON-LD built)
3. **VC\_SIGNED** (KMS signature attached; proof section populated)
4. **VC\_ANCHORED** (on-chain tx confirmed; txHash recorded)
5. **VC\_ACTIVE** (visible to subject; StatusList2021 = good)
6. **VC\_REVOKED** (issuer action or expiry; on-chain event + status list updated)

---

## 10) DID Support

* **User DIDs:** generated in mobile wallet (seed phrase → ed25519); app shares only **public DID**.
* **Issuer DID:** `did:web:onboardia.com` with published DID Document (well-known path) + `did:key` mirror.
* **Resolution:** Use AFGo resolver + `did:web` HTTP fetch; cache DID Docs with TTL & ETag.

---

## 11) Cloud Backup & Recovery (Client-Side)

* Mobile client encrypts wallet & VCs using **AES-256-GCM** with key derived via **Argon2id** from user’s backup passphrase; uploads to user cloud (Drive/iCloud).
* Backend only stores **backup metadata** (opaque blob refs) for convenience; **never** the decryption key.
* **Seed phrase** (BIP-39) export supported on device; backend has **zero access**.

---

## 12) Observability & Ops

* **Metrics:** Prometheus (latency, error budget, chain tx success, revocation SLAs)
* **Tracing:** OpenTelemetry (trace IDs propagate cross-svc)
* **Dashboards:** Grafana (KYC pass rate, anchor lag, VP verify time)
* **Alerts:** High failure rates, KMS errors, chain gas spikes, contract event stalls
* **CI/CD:**

  * SAST: `gosec`, `golangci-lint`
  * DAST: OWASP ZAP (staging)
  * Dependency scan: `govulncheck`
* **Infra as Code:** Terraform + least-priv IAM
* **Disaster Recovery:** DB PITR, object storage versioning, contract admin **multisig** for upgrades

---

## 13) Critical Libraries & Packages (Pin These)

* API: `github.com/gin-gonic/gin`, `google.golang.org/grpc`
* DB: `github.com/jackc/pgx/v5`, `sqlc`
* Cache/Limits: `github.com/redis/go-redis/v9`
* VC/DID: `github.com/hyperledger/aries-framework-go/pkg/doc/verifiable`, `.../pkg/doc/did`
* JOSE/JWS: `github.com/square/go-jose/v3`
* KMS: `github.com/hashicorp/vault/api` (or AWS SDK KMS)
* EVM: `github.com/ethereum/go-ethereum` (`ethclient`, `accounts/abi/bind`)
* Config: `github.com/kelseyhightower/envconfig`
* Validation: `github.com/go-playground/validator/v10`
* Logging: `go.uber.org/zap`
* Metrics/Tracing: `github.com/prometheus/client_golang`, `go.opentelemetry.io/otel`

---

## 14) Minimal Code Skeletons (Indicative)

### 14.1 VC Build/Sign (Go)

```go
vc := &verifiable.Credential{
  Context: []string{"https://www.w3.org/2018/credentials/v1"},
  Types:   []string{"VerifiableCredential", "KYCVerification"},
  Issuer:  verifiable.Issuer{ID: issuerDID},
  Issued:  util.NewTime(time.Now().UTC()),
  Subject: []verifiable.Subject{
    {ID: subjectDID, CustomFields: map[string]interface{}{"kycLevel":"basic","country":"NG"}},
  },
  ExpirationDate: util.NewTime(time.Now().UTC().Add(365*24*time.Hour)),
}

// canonicalize → hash for anchoring
normalized, _ := vc.MarshalJSON() // for demo; use proper RDF/JSON-LD canon
h := sha256.Sum256(normalized)

// sign via KMS → produce proof / JWS
jws, err := kmsSignJWS(kmsKeyID, normalized)
vc.Proofs = append(vc.Proofs, map[string]interface{}{
  "type": "Ed25519Signature2020",
  "created": time.Now().UTC().Format(time.RFC3339),
  "verificationMethod": issuerVerificationMethod,
  "proofPurpose": "assertionMethod",
  "jws": jws,
})
```

### 14.2 EVM Anchor (Go)

```go
tx, err := registry.Anchor(auth, h, uri) // h = [32]byte, uri = off-chain status URL
receipt, _ := bind.WaitMined(ctx, ethClient, tx)
```

---

## 15) Testing & Assurance

* **Unit tests** for VC creation, DID resolution, JWS verification
* **Contract tests** with anvil/hardhat + `abigen` clients
* **Golden tests** for JSON-LD normalization + hash stability
* **Security tests:** replay, nonce misuse, invalid DID methods, expired keys, chain reorg handling
* **Load tests:** p95 latency for `/vp/verify` < 400ms (cached DID docs, warm chain client)

---

## 16) Acceptance Criteria

* Issue, anchor, verify, revoke lifecycle works end-to-end on **Polygon testnet** with real tx hashes
* **No PII or biometrics** persisted beyond short TTL temp storage
* All keys **never** leave KMS/HSM
* DID Documents for issuer resolvable via `did:web` and include **current + previous** verification methods
* Revocation visible **both** on-chain and via StatusList endpoint
* Logs are redacted, signed (integrity), and exportable to SIEM

---

**Deliver this as working services + Helm charts + Terraform, with a demo script that:**

1. Creates a subject DID,
2. Submits KYC (mock ML pass),
3. Issues & anchors a VC,
4. Verifies VP from the subject,
5. Revokes the VC and confirms revocation on-chain & via API.

---
